// The Thresh finder is used to find the minimum current and voltage for a given
// setup (fiber diam, waveform shape, etc) to block an action potential (in this case a test pulse)

// Declaring the stimClamp that will generate the test pulse
objref stimClamp
// The test pulse will be generated at node 10
node[10] stimClamp = new IClamp(.5)
proc setStim(){
    // setStim(amplitude (nA), delay(ms), duration(ms))
    // setStim sets the parameters of the test stimulus
    // Requires that an object reference called stimClamp of type 
    //  IClamp has been declared and associated with an axon section

    stimClamp.amp=$1
    stimClamp.del=$2
    stimClamp.dur=$3
}

proc setAmps(){
    // Sets blocking electrode amperages to proper levels, depending on waveform and
    //  configuration, based on two parameters.  Param 1 is the amplitude of the first
    //  electrode (other two possible electrodes are dependent on this value) and 
    //  param 2 is the coefficient relating the anodic charge to the cathodic charge, only necessary for
    //  unbalanced waves.

    // Because hoc does not support else if statements
    //  nested if statements are needed
    // check if the waveform is a sine wave
    if (state_sin==1){
        amp1 = $1
        sine_val()
    } else {
        // check for a balanced square wave
        if (state_bal==1){
            if (electsel[0]==1 && electsel[1]==0 && electsel[2]==0){
                high_amp1 = $1
                bal_val1()
            }
            if (electsel[0]==0 && electsel[1]==1 && electsel[2]==0){
                high_amp1 = $1
                bal_val2()
            }
            if (electsel[0]==0 && electsel[1]==0 && electsel[2]==1){
                high_amp2 = $1
                bal_val3()
            }
        }else{
            // check for an unbalanced square wave
            if (state_unbal == 1){
                if (electsel[0]==1 && electsel[1]==0 && electsel[2]==0){
                    high_amp1 = $1
                    low_amp1 = (-1*$2*$1 * cathod_dur)/ anod_dur
                    unbal_val1()
                }
                if (electsel[0]==0 && electsel[1]==1 && electsel[2]==0){
                    high_amp1 = $1
                    low_amp1 =  (-1*$2*$1 * cathod_dur)/ anod_dur
                    unbal_val2()
                }
                if (electsel[0]==0 && electsel[1]==0 && electsel[2]==1){
                    high_amp2 = $1
                    low_amp2 =  (-1*$2*$1 * cathod_dur)/ anod_dur
                    unbal_val3()
                }
            }else{
                // check for a triangle wave
                if (state_tri==1){
                    if (electsel[0]) triamp=$1
                    if (electsel[1]) triamp=$1
                    if (electsel[2]) triamp=$1
                    tri_val()

                    // no wave was specified alert the error on the console
                }else{
                    if (state_dcsine==1){
                        dcamp = $1
                        sineamp = $1
                        dcsinestim()
                    }else{
                        print "Error: No waveform specified.\n" 
                    }
                } 
            }
        }
    }
    setAmplitudeElectrodes($1)
}


func countInitialSpikes(){
    // count initial spikes will count APs when there is no
    //  test stimulus, essentially meaning it will only count
    //  the number of APs generated from the current waveform
    // Param 1 is the amplitude of the first electrode 
    //  (other two are dependent on this value) and param 2 is the coefficient
    //  relating the anodic charge to the cathodic charge, only necessary for
    //  unbalanced waves.

    // reset the APCs
    APC_reset()

    // turn off the test stim pulse
    setStim(0,0,0)

    // set the current for the given waveform 
    setAmps($1, $2)

    // run the simulation
    run()

    // return the number of APs at the far end of the axon (opposite the side where
    //  test stimulus will be added)
    return APC_getCount(1)
}

func testWaveForm(){
    // testWaveForm tests whether a given waveform blocks an AP
    // The testing procedure occurs as follows:
    //  1. Check the number of APs generated by the waveform
    //   1a. Step 1 is skipped if running in 'efficient' mode
    //   1b. Check if the a steady state was reached by the time
    //          a test pulse would be generate (if no steady state return -1)
    //  2. Reset the APCount objects
    //  3. Set the test stimulus, and blocking wave
    //  4. Run the simulation
    //  5. Return a value of
    //      1, if AP was blocked
    //      0, if AP was not blocked
    //      -1, no steady state for frequency (step 1b)
    //      -2, if the stop flag is every on (also done at very beginning)
    //  6. Give output data to console

    // read all parameters
    testStimAmp = $1    // amplitude for test stimulus
    testStimDel = $2    // delay for test stimulus
    testStimDur = $3    // duration for test stimulus
    blockWaveAmp = $4   // amplitude of blocking wave
    blockWaveCo = $5    // coefficient relating the anodic charge to the cathodic charge, only necessary for unbalanced waves.

    // check for the stop flag, if its on return -2 immediately
    if(stop_flag == 1) return -2
 
    if(efficientState == 0) {    // 1.
        initialSpikes = countInitialSpikes(blockWaveAmp, blockWaveCo)

        // 1b. (note that there is atleast a 5ms padding before the test pulse)
        if(APC_getTime(1)-5 > testStimDel) {
            printOutputNoSteadyState()
            return -1
        }
    } else {
        // 1a.
        // if the efficient state is enabled, the user already knows the initial spikes
        initialSpikes = knownSpikes
    }

    // check for the stop flag, if its on return -2 immediately
    if(stop_flag == 1) return -2
    
    APC_reset() // 2.

    setStim(testStimAmp, testStimDel, testStimDur)  // 3.
    setAmps(blockWaveAmp, blockWaveCo)

    run()   // 4.

    // 5.
    if(stop_flag == 1) return -2
    if(APC_getCount(1) == initialSpikes) {wasBlocked = 1  // AP was blocked
    }else{ wasBlocked = 0}    // AP was not blocked

    printOutputSteadyState(wasBlocked)  // 6.
    return wasBlocked
}

func findThreshold(){
    // Find threshold will find the minimum current (amplitude) for the
    //  selected waveform that will still block an AP

    // Read parameters
    lower = $1  // lower bounds for amplitude search
    upper = $2  // upper bounds for amplitude search
    threshold = $3  // threshold for counting an AP
    stimAmp = $4    // test pulse amplitude
    stimDel = $5    // test pulse delay
    stimDur = $6    // test pulse duration
    waveCo = $7     // coefficient relating anodic charge to the cathodic charge, only necessary for unbanced square wave
    resolution = $8 // resolution for the search

    // check for valid ranges
    if (lower >= upper){
        continue_dialog("Error: Invalid range")
        return
    }

    // connect the APCounters to the model
    APC_connect()

    // set the threshold for the APCounters
    APC_setThresh(threshold)

    // set the stop flag to 0
    stop_flag = 0

    // set flags for checking that at some point the search finds a point
    //  at which an AP is blocked, a point where an AP is not blocked
    //  and a point where a steady state is reached
    hasBlocked = 0
    hasPassed = 0
    hasSteady = 0

    // initialize the level
    level = 0

    // print the output header to be able to know exactly what was recorded
    printOutputHeader()

    if(lower>=0){
        // begin positive binary search
        while(abs(lower-upper) > resolution && stop_flag==0){
            // find the midpoint of the two amplitudes
            level = (lower+upper)/2

            // run the simulation passing level as the amplitude
            blocked = testWaveForm(stimAmp, stimDel, stimDur, level, waveCo)
        
            // depending on whether the AP was blocked or not
            //  move the above or below the midpoint
            if(blocked == 1){
                // if the AP was blocked, move the search below the current level
                upper = level
            }else{
                // if the AP was not blocked move the search above the current level
                lower = level
            }

            // set flags for whether a steady state was reached, or if blocking or passing occured
            if(blocked != -1){
                // a steady state has occured, so the flag can be set to true
                if(hasSteady == 0) hasSteady = 1

                // check for blocking or passing, and make sure the flags 
                //  are set to the appropriate value
                if(blocked == 1 && hasBlocked == 0) hasBlocked = 1
                if(blocked == 0 && hasPassed == 0) hasPassed = 1
            }

            if(stop_flag == 1) return 0
        }
    } else{
        //begin negative binary search
        while(abs(lower-upper) > resolution && stop_flag==0){
            // find the midpoint of the two amplitudes
            level = (lower+upper)/2

            // run the simulation passing level as the amplitude
            blocked = testWaveForm(stimAmp, stimDel, stimDur, level, waveCo)
        
            // depending on whether the AP was blocked or not
            //  move the above or below the midpoint
            if(blocked == 1){
                // if the AP was blocked, move the search above the current level
                lower = level
            }else{
                // if the AP was not blocked move the search below the current level
                upper = level
            }

            // set flags for whether a steady state was reached, or if blocking or passing occured
            if(blocked != -1){
                // a steady state has occured, so the flag can be set to true
                if(hasSteady == 0) hasSteady = 1

                // check for blocking or passing, and make sure the flags 
                //  are set to the appropriate value
                if(blocked == 1 && hasBlocked == 0) hasBlocked = 1
                if(blocked == 0 && hasPassed == 0) hasPassed = 1
            }

            if(stop_flag == 1) return 0
        }
    }

    // check that blocking, passing, and steady states have occured
    //  if not print out what has happened
    if(!hasBlocked) print "The range was insufficient for blocking"
    if(!hasPassed) print "The range was insufficient for allowing APs"
    if(!hasSteady) print "The range never reached a steady state"
    if(!hasBlocked || !hasPassed || !hasSteady) return 0

    // if there was a successful search (all states were met) print
    //  and return the minimum value for blocking
    if(upper>0){
        print "Threshold for block,", upper
        return upper
    } else{
        print "Threshold for block,", lower
        return lower
    }
}

// OUTPUT METHODS
func printOutputHeader(){
    // outputs the list so that it is clear what data is what
    print "Outputs are given in the order :"
    print "1. Testing Amplitude"
    print "2. Was a stable state reached (0 for no, 1 for yes)"
    print "3. Count proximal spikes with stimulus (Left)"
    print "4. Time of last proximal spike (Left)"
    print "5. Count distal spikes with stimulus (Right)"
    print "6. Time of last distal spike (Right)"
    print "7. Count of distal spikes without stimulus (Right)"
    print "8. Was there a block (0 for no, 1 for yes)"
    return 0
}

func printOutputNoSteadyState(){
    // print output for a trial if no steady state was reached
    print level, ",0,,,,,,,"
    return 0
}

func printOutputSteadyState(){
    // printOutputSteadyState(wasBlocked)
    // print output for a trial if a steady state was reached
    print level, ",1,", APC_getCount(0), ",", APC_getTime(0), ",", APC_getCount(1), ",", APC_getTime(1), ",", initialSpikes, ",", $1
    return 0
}

// creating the GUI
// creating the thresholdbox object that will be the vbox for the GUI
objref thresholdbox
thresholdbox = new VBox()
proc setInitThreshParams(){
    lowB = 500000   // lower bound
    highB = 900000  // upper bound
    res = 1000  // resolution
    ap_thresh = -10 // threshold for AP

    stimAmp = 10    // test stim amp
    stimDur = .1    // test stim duration
    stimDel = 50    // test stim delay

    anode_coeff = 1 //anodic biphasic coefficient

    efficientState = 0  // efficient state flag
    knownSpikes = 0 //known number of initial spikes (goes with efficient state)

    lower = 0   // bounds and search values are not
    upper = 0   //  set initially
    level = 0
    
    setStim(stimAmp, stimDel, stimDur)  // set the stim values to the ones shown
}

proc drawThreshFinder(){
    // Draw the GUI for the threshFinder
    thresholdbox.intercept(1)
    xpanel("Search Parameters")
    xpvalue("Lower Bound (nA): ", &lowB)
    xpvalue("Upper Bound (nA): ", &highB)
    xpvalue("Search resolution : ", &res)
    xpvalue("APCount detection threshold (mV): ", &ap_thresh)
    xpanel()

    xpanel("Test Pulse Stimulus Parameters")
    xpvalue("Stimulus amperage (nA): ", &stimAmp)
    xpvalue("Stimulus delay (ms): ", &stimDel)
    xpvalue("Stimulus duration (ms): ", &stimDur)
    xbutton("Update stimulus values", "setStim(stimamp, stimdel, stimdur)")
    xpanel()

    xpanel("Waveform Parameters")
    xpvalue("Anodic Coefficient : ", &anode_coeff)
    xpanel()

    xpanel("Go!")
    xbutton("Find threshold", "findThreshold(lowB, highB, ap_thresh, stimamp, stimdel, stimdur, anode_coeff, res)")
    xbutton("Stop", "stopRun()")
    xcheckbox("Efficient search (will not record # of initial spikes)", &efficientState)
    xpvalue("Number of known Init spikes (for efficient search) : ", &knownSpikes)
    xlabel("")
    xpanel()

    xpanel("State variables")
    xlabel("These values for informational purposes only.  Do not modify.")
    xpvalue("Current Lower Bound: ", &lower)
    xpvalue("Current upper Bound: ", &upper)
    xpvalue("Current HFAC test amplitude: ", &level)
    xpanel()
    thresholdbox.intercept(0)
    thresholdbox.map("Threshold detector", 550, 375, -1, -1)
}
setInitThreshParams()
drawThreshFinder()

proc stopRun(){
    // stop run will allow the user to stop a run if something is going wrong
    stop_flag = 1
    stoprun = 1
}