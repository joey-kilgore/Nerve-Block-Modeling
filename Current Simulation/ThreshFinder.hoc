// The Thresh finder is used to find the minimum current and voltage for a given
// setup (fiber diam, waveform shape, etc) to block

efficientState = 0


// Declaring the stimClamp that will generate the test pulse
objref stimClamp
// The test pulse will be generated at node 10
node[10] stimClamp = new IClamp(.5)
proc setStim(){
    // setStim(amplitude (nA), delay(ms), duration(ms))
    // setStim sets the parameters of the test stimulus
    // Requires that an object reference called stimClamp of type 
    //  IClamp has been declared and associated with an axon section

    stimClamp.amp=$1
    stimClamp.del=$2
    stimClamp.dur=$3
}

// the initial setup has the simclamp set with an amplitude of 10nA, a delay of 40ms
//  and a durationg of .1ms
setStim(10, 40, .1)


proc setAmps(){
    // Sets blocking electrode amperages to proper levels, depending on waveform and
    //  configuration, based on two parameters.  Param 1 is the amplitude of the first
    //  electrode (other two are dependent on this value) and param 2 is the coefficient
    //  relating the anodic charge to the cathodic charge, only necessary for
    //  unbalanced waves.

    // Because hoc does not support else if statements
    //  nested if statements are needed
    // check if the waveform is a sine wave
    if (state_sin==1){
        amp1 = $1
        sine_val()
    } else {
        // check for a balanced square wave
        if (state_bal==1){
            if (electsel[0]==1 && electsel[1]==0 && electsel[2]==0){
                high_amp1 = $1
                bal_val1()
            }
            if (electsel[0]==0 && electsel[1]==1 && electsel[2]==0){
                high_amp1 = $1
                bal_val2()
            }
            if (electsel[0]==0 && electsel[1]==0 && electsel[2]==1){
                high_amp2 = $1
                bal_val3()
            }
        }else{
            // check for an unbalanced square wave
            if (state_unbal == 1){
                if (electsel[0]==1 && electsel[1]==0 && electsel[2]==0){
                    high_amp1 = $1
                    low_amp1 = (-1*$2*$1 * cathod_dur)/ anod_dur
                    unbal_val1()
                }
                if (electsel[0]==0 && electsel[1]==1 && electsel[2]==0){
                    high_amp1 = $1
                    low_amp1 =  (-1*$2*$1 * cathod_dur)/ anod_dur
                    unbal_val2()
                }
                if (electsel[0]==0 && electsel[1]==0 && electsel[2]==1){
                    high_amp2 = $1
                    low_amp2 =  (-1*$2*$1 * cathod_dur)/ anod_dur
                    unbal_val3()
                }
            }else{
                // check for a triangle wave
                if (state_tri==1){
                    print "Tri"
                    if (electsel[0]) triamp=$1
                    if (electsel[1]) triamp=$1
                    if (electsel[2]) triamp=$1
                    tri_val()

                    // no wave was specified alert the error on the console
                }else print "Error: No waveform specified.\n" 
            }
        }
    }
}


func countInitialSpikes(){
    // count initial spikes will count APs when there is no
    //  test stimulus, essentially meaning it will only count
    //  the number of APs generated from the current waveform
    // Param 1 is the amplitude of the first electrode 
    //  (other two are dependent on this value) and param 2 is the coefficient
    //  relating the anodic charge to the cathodic charge, only necessary for
    //  unbalanced waves.

    // reset the APCs
    APC_reset()

    // turn off the test stim pulse
    setStim(0,0,0)

    // set the current for the given waveform 
    setAmps($1, $2)

    // run the simulation
    run()

    // return the number of APs at the far end of the axon (opposite the side where
    //  test stimulus will be added)
    return APC_getCount(1)
}

func testWaveForm(){
    // testWaveForm tests whether a given waveform blocks an AP
    // The testing procedure occurs as follows:
    //  1. Check the number of APs generated by the waveform
    //   1a. Step 1 is skipped if running in 'efficient' mode
    //   1b. Check if the a steady state was reached by the time
    //          a test pulse would be generate (if no steady state return -1)
    //  2. Reset the APCount objects
    //  3. Set the test stimulus, and blocking wave
    //  4. Run the simulation
    //  5. Print out the number of Proximal and Distal spikes
    //  6. Return a value of
    //      1, if AP was blocked
    //      0, if AP was not blocked
    //      -1, no steady state for frequency (step 1b)
    //      -2, if the stop flag is every on (also done at very beginning)

    // read all parameters
    testStimAmp = $1    // amplitude for test stimulus
    testStimDel = $2    // delay for test stimulus
    testStimDur = $3    // duration for test stimulus
    blockWaveAmp = $4   // amplitude of blocking wave
    blockWaveCo = $5    // coefficient relating the anodic charge to the cathodic charge, only necessary for unbalanced waves.

    // check for the stop flag, if its on return -2 immediately
    if(stop_flag == 1) return -2
 
    if(efficientState == 0) {    // 1.
        initialSpikes = countInitialSpikes(blockWaveAmp, blockWaveCo)

        // 1b. (note that there is atleast a 5ms padding before the test pulse)
        if(APC_getTime(1)-5 > testStimDel) {
            printOutputNoSteadyState()
            return -1
        }
    }

    APC_reset() // 2.

    setStim(testStimAmp, testStimDel, testStimDur)  // 3.
    setAmps(blockWaveAmp, blockWaveCo)

    run()   // 4.

    // 6.
    if(stop_flag == 1) return -2
    if(APC_getCount(1) == initialSpikes) {wasBlocked = 1  // AP was blocked
    }else{ wasBlocked = 0}    // AP was not blocked

    printOutputSteadyState(wasBlocked)
    return wasBlocked
}

func findThreshold(){
    // Find threshold will find the minimum current (amplitude) for the
    //  selected waveform that will still block an AP

    // Read parameters
    lower = $1  // lower bounds for amplitude search
    upper = $2  // upper bounds for amplitude search
    threshold = $3  // threshold for counting an AP
    stimAmp = $4    // test pulse amplitude
    stimDel = $5    // test pulse delay
    stimDur = $6    // test pulse duration
    waveCo = $7     // coefficient relating anodic charge to the cathodic charge, only necessary for unbanced square wave
    resolution = $8 // resolution for the search
    // check for valid ranges
    if (lower >= upper){
        continue_dialog("Error: Invalid range")
        return
    }
    if(lower<0 || upper<0){
        continue_dialog("Error: Negative range not allowed")
        return
    }

    // connect the APCounters to the model
    APC_connect()

    // set the threshold for the APCounters
    APC_setThresh(threshold)

    // set the stop flag to 0
    stop_flag = 0

    // set flags for checking that at some point the search finds a point
    //  at which an AP is blocked, a point where an AP is not blocked
    //  and a point where a steady state is reached
    hasBlocked = 0
    hasPassed = 0
    hasSteady = 0

    // initialize the level
    level = 0

    // print the output header to be able to know exactly what was recorded
    printOutputHeader()

    // begin binary search
    while(abs(lower-upper) > resolution && stop_flag==0){
        // find the midpoint of the two amplitudes
        level = (lower+upper)/2

        // run the simulation passing level as the amplitude
        blocked = testWaveForm(stimAmp, stimDel, stimDur, level, waveCo)
    
        // depending on whether the AP was blocked or not
        //  move the above or below the midpoint
        if(blocked == 1){
            // if the AP was blocked, move the search below the current level
            upper = level
        }else{
            // if the AP was not blocked move the search above the current level
            lower = level
        }

        // set flags for whether a steady state was reached, or if blocking or passing occured
        if(blocked != -1){
            // a steady state has occured, so the flag can be set to true
            if(hasSteady == 0) hasSteady = 1

            // check for blocking or passing, and make sure the flags 
            //  are set to the appropriate value
            if(blocked == 1 && hasBlocked == 0) hasBlocked = 1
            if(blocked == 0 && hasPassed == 0) hasPassed = 1
        }

        if(stop_flag == 1) return 0
    }

    // check that blocking, passing, and steady states have occured
    //  if not print out what has happened
    if(!hasBlocked) print "The range was insufficient for blocking"
    if(!hasPassed) print "The range was insufficient for allowing APs"
    if(!hasSteady) print "The range never reached a steady state"
    if(!hasBlocked || !hasPassed || !hasSteady) return 0

    // if there was a successful search (all states were met) print
    //  and return the minimum value for blocking
    // because the last value could be either a block or a pass, 
    //  adding the resolution will mean the amplitude certainly blocked
    minimumBlock = level + resolution

    print "Threshold for block = ", minimumBlock
    return minimumBlock
}

func printOutputHeader(){
    print "Outputs are given in the order :"
    print "1. Testing Amplitude"
    print "2. Was a stable state reached (0 for no, 1 for yes)"
    print "3. Count proximal spikes with stimulus"
    print "4. Time of last proximal spike"
    print "5. Count distal spikes with stimulus"
    print "6. Time of last distal spike"
    print "7. Count of distal spikes without stimulus"
    print "8. Was there a block (0 for no, 1 for yes)"
    return 0
}

func printOutputNoSteadyState(){
    // print output for a trial if no steady state was reached
    print level, ",0,,,,,,,"
    return 0
}

func printOutputSteadyState(){
    // printOutputSteadyState(wasBlocked)
    // print output for a trial if a steady state was reached
    print level, ",1,", APC_getCount(0), ",", APC_getTime(0), ",", APC_getCount(1), ",", APC_getTime(1), ",", initialSpikes, ",", $1
    return 0
}

func testIt(){
    return findThreshold(500000,900000,10,10,50,.1,1,1000)
}