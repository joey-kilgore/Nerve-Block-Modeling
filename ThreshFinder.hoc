// The Thresh finder is used to find the minimum current and voltage for a given
// setup (fiber diam, waveform shape, etc) to block




// Declaring the stimClamp that will generate the test pulse
objref stimClamp
// The test pulse will be generated at node 10
node[10] stimClamp = new IClamp(.5)
proc setStim(){
    // setStim(amplitude (nA), delay(ms), duration(ms))
    // setStim sets the parameters of the test stimulus
    // Requires that an object reference called stimClamp of type 
    //  IClamp has been declared and associated with an axon section

    stimClamp.amp=$1
    stimClamp.del=$2
    stimClamp.dur=$3
}



proc setAmps(){
    // Sets blocking electrode amperages to proper levels, depending on waveform and
    //  configuration, based on two parameters.  Param 1 is the amplitude of the first
    //  electrode (other two are dependent on this value) and param 2 is the coefficient
    //  relating the anodic charge to the cathodic charge, only necessary for
    //  unbalanced waves.

    // Because hoc does not support else if statements
    //  nested if statements are needed
    // check if the waveform is a sine wave
    if (state_sin==1){
        amp1 = $1
        sine_val()
    } else {
        // check for a balanced square wave
        if (state_bal==1){
            if (electsel[0]==1 && electsel[1]==0 && electsel[2]==0){
                high_amp1 = $1
                bal_val1()
            }
            if (electsel[0]==0 && electsel[1]==1 && electsel[2]==0){
                high_amp1 = $1
                bal_val2()
            }
            if (electsel[0]==0 && electsel[1]==0 && electsel[2]==1){
                high_amp2 = $1
                bal_val3()
            }
        }else{
            // check for an unbalanced square wave
            if (state_unbal == 1){
                if (electsel[0]==1 && electsel[1]==0 && electsel[2]==0){
                    high_amp1 = $1
                    low_amp1 = (-1*$2*$1 * cathod_dur)/ anod_dur
                    unbal_val1()
                }
                if (electsel[0]==0 && electsel[1]==1 && electsel[2]==0){
                    high_amp1 = $1
                    low_amp1 =  (-1*$2*$1 * cathod_dur)/ anod_dur
                    unbal_val2()
                }
                if (electsel[0]==0 && electsel[1]==0 && electsel[2]==1){
                    high_amp2 = $1
                    low_amp2 =  (-1*$2*$1 * cathod_dur)/ anod_dur
                    unbal_val3()
                }
            }else{
                // check for a triangle wave
                if (state_tri==1){
                    print "Tri"
                    if (electsel[0]) triamp=$1
                    if (electsel[1]) triamp=$1
                    if (electsel[2]) triamp=$1
                    tri_val()

                    // no wave was specified alert the error on the console
                }else print "Error: No waveform specified.\n" 
            }
        }
    }
}


func countInitialSpikes(){
    // count initial spikes will count APs when there is no
    //  test stimulus, essentially meaning it will only count
    //  the number of APs generated from the current waveform
    // Param 1 is the amplitude of the first electrode 
    //  (other two are dependent on this value) and param 2 is the coefficient
    //  relating the anodic charge to the cathodic charge, only necessary for
    //  unbalanced waves.

    // reset the APCs
    APC_reset()

    // turn off the test stim pulse
    setStim(0,0,0)

    // set the current for the given waveform 
    setAmps($1, $2)

    // run the simulation
    run()

    // return the number of APs at the far end of the axon (opposite the side where
    //  test stimulus will be added)
    return APC_getCount(1)
}

func testWaveForm(){
    // testWaveForm tests whether a given waveform blocks an AP
    // The testing procedure occurs as follows:
    //  1. Check the number of APs generated by the waveform
    //   1a. Step 1 is skipped if running in 'efficient' mode
    //   1b. Check if the a steady state was reached by the time
    //          a test pulse would be generate (if no steady state return -1)
    //  2. Reset the APCount objects
    //  3. Set the test stimulus, and blocking wave
    //  4. Run the simulation
    //  5. Print out the number of Proximal and Distal spikes
    //  6. Return a value of
    //      1, if AP was blocked
    //      0, if AP was not blocked
    //      -1, no steady state for frequency (step 1b)
    //      -2, if the stop flag is every on (also done at very beginning)

    // read all parameters
    testStimAmp = $1    // amplitude for test stimulus
    testStimDel = $2    // delay for test stimulus
    testStimDur = $3    // duration for test stimulus
    blockWaveAmp = $4   // amplitude of blocking wave
    blockWaveCo = $5    // coefficient relating the anodic charge to the cathodic charge, only necessary for unbalanced waves.

    // check for the stop flag, if its on return -2 immediately
    if(stop_flag == 1) return -2
 
    if(efficientState == 0) {    // 1.
        initialSpikes = countInitialSpikes(blockWaveAmp, blockWaveCo)

        // 1b. (note that there is atleast a 5ms padding before the test pulse)
        if(APC_getTime(1)-5 > testStimDel) return -1
    }

    APC_reset() // 2.

    setStim(testStimAmp, testStimDel, testStimDur)  // 3.
    setAmps(blockWaveAmp, blockWaveCo)

    run()   // 4.

    print "Proximal spikes = ", APC_getCount(0) // 5.
    print "Distal spikes = ", APC_getCount(1) 
    print "Distal spikes without test pulse = ", initialSpikes

    // 6.
    if(stop_flag == 1) return -2
    if(APC_getCount(1) == initialSpikes) return 1  // AP was blocked
    return 0    // AP was not blocked
}
